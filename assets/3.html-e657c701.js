const e=JSON.parse('{"key":"v-7bb44dc6","path":"/zh/posts/WPF_CommunitToolkit/3.html","title":"CommunityToolkit 用 Messenger 来进行 ViewModel 之间的通信","lang":"zh-CN","frontmatter":{"lang":"zh-CN","icon":"pen-to-square","date":"2023-11-21T00:00:00.000Z","isOriginal":false,"category":["CommunityToolkit"],"tag":["框架","WPF"],"description":"CommunityToolkit 用 Messenger 来进行 ViewModel 之间的通信 1.Message 简单原理 // LINQ var rec = new MessageReceiver(); EventAggregator.Instance.Send(new StringMessage(\\"hello world\\")); class MessageReceiver { public MessageReceiver() { // 注册一个 StringMessage类型 EventAggregator.Instance.Register&lt;StringMessage&gt;(this,Receive); } // 执行方法 void Receive(StringMessage m) { m.Message.Dump(\\"string message received\\"); } } record StringMessage(string Message); class EventAggregator { // 单例模式 public static EventAggregator Instance { get; } = new EventAggregator(); // 记录执行对象及方法 record MessageReceiver(object Receiver, Action&lt;object&gt; Method); // 创建一个 字典 key 是泛型 类型, value 储存 传递过来的类 以及 委托 private Dictionary&lt;Type,List&lt;MessageReceiver&gt;&gt; events = new(); // 订阅接收消息 public void Register&lt;TMessage&gt;(object receiver, Action&lt;TMessage&gt; method) { var type = typeof(TMessage); if (!events.ContainsKey(type)) events[type]= new List&lt;MessageReceiver&gt;(); // 存入list , 类 及 委托, 无法将派生类直接按基类进行传递, 可以先传递object 然后回调为 TMessage events[type].Add(new(receiver,o=&gt; method((TMessage)o))); } // 发送消息 所有订阅Message类型方法的 订阅者接收消息 public void Send&lt;Tmessage&gt;(Tmessage message) { var type = typeof(Tmessage); if (!events.ContainsKey(type)) return; foreach (var rec in events[type]) { rec.Method.Invoke(message); } } } // Results // string message received // hello world","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/zh/posts/WPF_CommunitToolkit/3.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"CommunityToolkit 用 Messenger 来进行 ViewModel 之间的通信"}],["meta",{"property":"og:description","content":"CommunityToolkit 用 Messenger 来进行 ViewModel 之间的通信 1.Message 简单原理 // LINQ var rec = new MessageReceiver(); EventAggregator.Instance.Send(new StringMessage(\\"hello world\\")); class MessageReceiver { public MessageReceiver() { // 注册一个 StringMessage类型 EventAggregator.Instance.Register&lt;StringMessage&gt;(this,Receive); } // 执行方法 void Receive(StringMessage m) { m.Message.Dump(\\"string message received\\"); } } record StringMessage(string Message); class EventAggregator { // 单例模式 public static EventAggregator Instance { get; } = new EventAggregator(); // 记录执行对象及方法 record MessageReceiver(object Receiver, Action&lt;object&gt; Method); // 创建一个 字典 key 是泛型 类型, value 储存 传递过来的类 以及 委托 private Dictionary&lt;Type,List&lt;MessageReceiver&gt;&gt; events = new(); // 订阅接收消息 public void Register&lt;TMessage&gt;(object receiver, Action&lt;TMessage&gt; method) { var type = typeof(TMessage); if (!events.ContainsKey(type)) events[type]= new List&lt;MessageReceiver&gt;(); // 存入list , 类 及 委托, 无法将派生类直接按基类进行传递, 可以先传递object 然后回调为 TMessage events[type].Add(new(receiver,o=&gt; method((TMessage)o))); } // 发送消息 所有订阅Message类型方法的 订阅者接收消息 public void Send&lt;Tmessage&gt;(Tmessage message) { var type = typeof(Tmessage); if (!events.ContainsKey(type)) return; foreach (var rec in events[type]) { rec.Method.Invoke(message); } } } // Results // string message received // hello world"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-22T17:51:39.000Z"}],["meta",{"property":"article:author","content":"Mr.SpaceTime"}],["meta",{"property":"article:tag","content":"框架"}],["meta",{"property":"article:tag","content":"WPF"}],["meta",{"property":"article:published_time","content":"2023-11-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-22T17:51:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CommunityToolkit 用 Messenger 来进行 ViewModel 之间的通信\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-11-21T00:00:00.000Z\\",\\"dateModified\\":\\"2023-11-22T17:51:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.SpaceTime\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1.Message 简单原理","slug":"_1-message-简单原理","link":"#_1-message-简单原理","children":[]},{"level":2,"title":"1.Toolkit 使用Message","slug":"_1-toolkit-使用message","link":"#_1-toolkit-使用message","children":[]},{"level":2,"title":"1. Toolkit Message 返回值","slug":"_1-toolkit-message-返回值","link":"#_1-toolkit-message-返回值","children":[]},{"level":2,"title":"1. ObservableRecipient 进一步简化","slug":"_1-observablerecipient-进一步简化","link":"#_1-observablerecipient-进一步简化","children":[]}],"git":{"createdTime":1700499761000,"updatedTime":1700675499000,"contributors":[{"name":"时空","email":"Space_Time_@outlook.com","commits":2}]},"readingTime":{"minutes":1.93,"words":578},"filePathRelative":"zh/posts/WPF&CommunitToolkit/3.md","localizedDate":"2023年11月21日","excerpt":"<h1> CommunityToolkit 用 Messenger 来进行 ViewModel 之间的通信</h1>\\n<h2> 1.Message 简单原理</h2>\\n<div class=\\"language-C# line-numbers-mode\\" data-ext=\\"C#\\"><pre class=\\"language-C#\\"><code>// LINQ\\nvar rec = new MessageReceiver();\\nEventAggregator.Instance.Send(new StringMessage(\\"hello world\\"));\\n\\nclass MessageReceiver\\n{\\n public MessageReceiver()\\n {\\n  // 注册一个 StringMessage类型\\n  EventAggregator.Instance.Register&lt;StringMessage&gt;(this,Receive);\\n }\\n // 执行方法\\n void Receive(StringMessage m)\\n {\\n  m.Message.Dump(\\"string message received\\");\\n }\\n}\\nrecord StringMessage(string Message);\\nclass EventAggregator\\n{\\n // 单例模式\\n public static EventAggregator Instance { get; } = new EventAggregator();\\n // 记录执行对象及方法\\n record MessageReceiver(object Receiver, Action&lt;object&gt; Method);\\n // 创建一个 字典 key 是泛型 类型, value 储存 传递过来的类 以及 委托\\n private Dictionary&lt;Type,List&lt;MessageReceiver&gt;&gt; events = new();\\n // 订阅接收消息\\n public void Register&lt;TMessage&gt;(object receiver, Action&lt;TMessage&gt; method)\\n {\\n  var type = typeof(TMessage);\\n  if (!events.ContainsKey(type))\\n   events[type]= new List&lt;MessageReceiver&gt;();\\n  // 存入list , 类 及 委托,  无法将派生类直接按基类进行传递, 可以先传递object 然后回调为 TMessage\\n  events[type].Add(new(receiver,o=&gt; method((TMessage)o)));\\n }\\n // 发送消息 所有订阅Message类型方法的 订阅者接收消息\\n public void Send&lt;Tmessage&gt;(Tmessage message)\\n {\\n  var type = typeof(Tmessage);\\n  if (!events.ContainsKey(type))\\n   return;\\n  foreach (var rec in events[type])\\n  {\\n   rec.Method.Invoke(message);\\n  }\\n }\\n}\\n\\n// Results\\n// string message received\\n// hello world\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","copyright":{"author":"Mr.SpaceTime"},"autoDesc":true}');export{e as data};
